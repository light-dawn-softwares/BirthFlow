// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'paridad.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$Paridad {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() todas,
    required TResult Function() multiparas,
    required TResult Function() nuliparas,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? todas,
    TResult? Function()? multiparas,
    TResult? Function()? nuliparas,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? todas,
    TResult Function()? multiparas,
    TResult Function()? nuliparas,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ParidadInit value) init,
    required TResult Function(ParidadTodas value) todas,
    required TResult Function(ParidadMultiparas value) multiparas,
    required TResult Function(ParidadNuliparas value) nuliparas,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ParidadInit value)? init,
    TResult? Function(ParidadTodas value)? todas,
    TResult? Function(ParidadMultiparas value)? multiparas,
    TResult? Function(ParidadNuliparas value)? nuliparas,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ParidadInit value)? init,
    TResult Function(ParidadTodas value)? todas,
    TResult Function(ParidadMultiparas value)? multiparas,
    TResult Function(ParidadNuliparas value)? nuliparas,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ParidadCopyWith<$Res> {
  factory $ParidadCopyWith(Paridad value, $Res Function(Paridad) then) =
      _$ParidadCopyWithImpl<$Res, Paridad>;
}

/// @nodoc
class _$ParidadCopyWithImpl<$Res, $Val extends Paridad>
    implements $ParidadCopyWith<$Res> {
  _$ParidadCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ParidadInitImplCopyWith<$Res> {
  factory _$$ParidadInitImplCopyWith(
          _$ParidadInitImpl value, $Res Function(_$ParidadInitImpl) then) =
      __$$ParidadInitImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ParidadInitImplCopyWithImpl<$Res>
    extends _$ParidadCopyWithImpl<$Res, _$ParidadInitImpl>
    implements _$$ParidadInitImplCopyWith<$Res> {
  __$$ParidadInitImplCopyWithImpl(
      _$ParidadInitImpl _value, $Res Function(_$ParidadInitImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ParidadInitImpl extends ParidadInit {
  const _$ParidadInitImpl() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ParidadInitImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() todas,
    required TResult Function() multiparas,
    required TResult Function() nuliparas,
  }) {
    return init();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? todas,
    TResult? Function()? multiparas,
    TResult? Function()? nuliparas,
  }) {
    return init?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? todas,
    TResult Function()? multiparas,
    TResult Function()? nuliparas,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ParidadInit value) init,
    required TResult Function(ParidadTodas value) todas,
    required TResult Function(ParidadMultiparas value) multiparas,
    required TResult Function(ParidadNuliparas value) nuliparas,
  }) {
    return init(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ParidadInit value)? init,
    TResult? Function(ParidadTodas value)? todas,
    TResult? Function(ParidadMultiparas value)? multiparas,
    TResult? Function(ParidadNuliparas value)? nuliparas,
  }) {
    return init?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ParidadInit value)? init,
    TResult Function(ParidadTodas value)? todas,
    TResult Function(ParidadMultiparas value)? multiparas,
    TResult Function(ParidadNuliparas value)? nuliparas,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init(this);
    }
    return orElse();
  }
}

abstract class ParidadInit extends Paridad {
  const factory ParidadInit() = _$ParidadInitImpl;
  const ParidadInit._() : super._();
}

/// @nodoc
abstract class _$$ParidadTodasImplCopyWith<$Res> {
  factory _$$ParidadTodasImplCopyWith(
          _$ParidadTodasImpl value, $Res Function(_$ParidadTodasImpl) then) =
      __$$ParidadTodasImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ParidadTodasImplCopyWithImpl<$Res>
    extends _$ParidadCopyWithImpl<$Res, _$ParidadTodasImpl>
    implements _$$ParidadTodasImplCopyWith<$Res> {
  __$$ParidadTodasImplCopyWithImpl(
      _$ParidadTodasImpl _value, $Res Function(_$ParidadTodasImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ParidadTodasImpl extends ParidadTodas {
  const _$ParidadTodasImpl() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ParidadTodasImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() todas,
    required TResult Function() multiparas,
    required TResult Function() nuliparas,
  }) {
    return todas();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? todas,
    TResult? Function()? multiparas,
    TResult? Function()? nuliparas,
  }) {
    return todas?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? todas,
    TResult Function()? multiparas,
    TResult Function()? nuliparas,
    required TResult orElse(),
  }) {
    if (todas != null) {
      return todas();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ParidadInit value) init,
    required TResult Function(ParidadTodas value) todas,
    required TResult Function(ParidadMultiparas value) multiparas,
    required TResult Function(ParidadNuliparas value) nuliparas,
  }) {
    return todas(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ParidadInit value)? init,
    TResult? Function(ParidadTodas value)? todas,
    TResult? Function(ParidadMultiparas value)? multiparas,
    TResult? Function(ParidadNuliparas value)? nuliparas,
  }) {
    return todas?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ParidadInit value)? init,
    TResult Function(ParidadTodas value)? todas,
    TResult Function(ParidadMultiparas value)? multiparas,
    TResult Function(ParidadNuliparas value)? nuliparas,
    required TResult orElse(),
  }) {
    if (todas != null) {
      return todas(this);
    }
    return orElse();
  }
}

abstract class ParidadTodas extends Paridad {
  const factory ParidadTodas() = _$ParidadTodasImpl;
  const ParidadTodas._() : super._();
}

/// @nodoc
abstract class _$$ParidadMultiparasImplCopyWith<$Res> {
  factory _$$ParidadMultiparasImplCopyWith(_$ParidadMultiparasImpl value,
          $Res Function(_$ParidadMultiparasImpl) then) =
      __$$ParidadMultiparasImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ParidadMultiparasImplCopyWithImpl<$Res>
    extends _$ParidadCopyWithImpl<$Res, _$ParidadMultiparasImpl>
    implements _$$ParidadMultiparasImplCopyWith<$Res> {
  __$$ParidadMultiparasImplCopyWithImpl(_$ParidadMultiparasImpl _value,
      $Res Function(_$ParidadMultiparasImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ParidadMultiparasImpl extends ParidadMultiparas {
  const _$ParidadMultiparasImpl() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ParidadMultiparasImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() todas,
    required TResult Function() multiparas,
    required TResult Function() nuliparas,
  }) {
    return multiparas();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? todas,
    TResult? Function()? multiparas,
    TResult? Function()? nuliparas,
  }) {
    return multiparas?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? todas,
    TResult Function()? multiparas,
    TResult Function()? nuliparas,
    required TResult orElse(),
  }) {
    if (multiparas != null) {
      return multiparas();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ParidadInit value) init,
    required TResult Function(ParidadTodas value) todas,
    required TResult Function(ParidadMultiparas value) multiparas,
    required TResult Function(ParidadNuliparas value) nuliparas,
  }) {
    return multiparas(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ParidadInit value)? init,
    TResult? Function(ParidadTodas value)? todas,
    TResult? Function(ParidadMultiparas value)? multiparas,
    TResult? Function(ParidadNuliparas value)? nuliparas,
  }) {
    return multiparas?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ParidadInit value)? init,
    TResult Function(ParidadTodas value)? todas,
    TResult Function(ParidadMultiparas value)? multiparas,
    TResult Function(ParidadNuliparas value)? nuliparas,
    required TResult orElse(),
  }) {
    if (multiparas != null) {
      return multiparas(this);
    }
    return orElse();
  }
}

abstract class ParidadMultiparas extends Paridad {
  const factory ParidadMultiparas() = _$ParidadMultiparasImpl;
  const ParidadMultiparas._() : super._();
}

/// @nodoc
abstract class _$$ParidadNuliparasImplCopyWith<$Res> {
  factory _$$ParidadNuliparasImplCopyWith(_$ParidadNuliparasImpl value,
          $Res Function(_$ParidadNuliparasImpl) then) =
      __$$ParidadNuliparasImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ParidadNuliparasImplCopyWithImpl<$Res>
    extends _$ParidadCopyWithImpl<$Res, _$ParidadNuliparasImpl>
    implements _$$ParidadNuliparasImplCopyWith<$Res> {
  __$$ParidadNuliparasImplCopyWithImpl(_$ParidadNuliparasImpl _value,
      $Res Function(_$ParidadNuliparasImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ParidadNuliparasImpl extends ParidadNuliparas {
  const _$ParidadNuliparasImpl() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ParidadNuliparasImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() todas,
    required TResult Function() multiparas,
    required TResult Function() nuliparas,
  }) {
    return nuliparas();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? todas,
    TResult? Function()? multiparas,
    TResult? Function()? nuliparas,
  }) {
    return nuliparas?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? todas,
    TResult Function()? multiparas,
    TResult Function()? nuliparas,
    required TResult orElse(),
  }) {
    if (nuliparas != null) {
      return nuliparas();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ParidadInit value) init,
    required TResult Function(ParidadTodas value) todas,
    required TResult Function(ParidadMultiparas value) multiparas,
    required TResult Function(ParidadNuliparas value) nuliparas,
  }) {
    return nuliparas(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ParidadInit value)? init,
    TResult? Function(ParidadTodas value)? todas,
    TResult? Function(ParidadMultiparas value)? multiparas,
    TResult? Function(ParidadNuliparas value)? nuliparas,
  }) {
    return nuliparas?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ParidadInit value)? init,
    TResult Function(ParidadTodas value)? todas,
    TResult Function(ParidadMultiparas value)? multiparas,
    TResult Function(ParidadNuliparas value)? nuliparas,
    required TResult orElse(),
  }) {
    if (nuliparas != null) {
      return nuliparas(this);
    }
    return orElse();
  }
}

abstract class ParidadNuliparas extends Paridad {
  const factory ParidadNuliparas() = _$ParidadNuliparasImpl;
  const ParidadNuliparas._() : super._();
}
